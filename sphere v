from manim import *
import numpy as np

from manim import *
import numpy as np

class RaySphereIntersection(ThreeDScene):
    def construct(self):
        # Camera setup
        self.set_camera_orientation(phi=60 * DEGREES, theta=-45 * DEGREES)
        
        # Title sequence
        title = Text("Ray-Sphere Intersection Algorithm", font_size=48)
        subtitle = Text("Geometric & Algebraic Approach", font_size=28, color=GRAY)
        title_group = VGroup(title, subtitle).arrange(DOWN)
        title_group.to_edge(UP)
        
        self.add_fixed_in_frame_mobjects(title_group)
        self.play(Write(title), Write(subtitle))
        self.wait(3)  # Give viewers time to read
        self.play(FadeOut(title_group))  # Fade out the entire title group
        self.remove(title_group)  # Remove from fixed mobjects
        self.wait(0.5)  # Brief pause after title removal
        
        # Create 3D scene elements
        axes = self.create_axes()
        sphere, sphere_elements = self.create_sphere()
        
        self.play(Create(axes), Create(sphere))
        self.add_fixed_in_frame_mobjects(*sphere_elements)
        self.play(*[Write(elem) for elem in sphere_elements])
        
        # Show algorithm steps (and fade them out after)
        self.show_algorithm_overview()
        
        # Demonstrate three cases with symbolic math
        cases = [
            {
                "origin": np.array([-3, -0.8, 0]),
                "direction": np.array([1, 0.3, 0]),
                "name": "Two Intersections",
                "color": GREEN,
                "symbol": r"\Delta > 0"
            },
            {
                "origin": np.array([-3, 1.5, 0]),
                "direction": np.array([1, 0, 0]),
                "name": "Tangent Ray",
                "color": ORANGE,
                "symbol": r"\Delta = 0"
            },
            {
                "origin": np.array([-3, 2.5, 0]),
                "direction": np.array([1, 0, 0]),
                "name": "No Intersection",
                "color": RED,
                "symbol": r"\Delta < 0"
            }
        ]
        
        for case in cases:
            self.demonstrate_case(axes, sphere, **case)
        
        # Final flourish
        self.begin_ambient_camera_rotation(rate=0.15)
        self.wait(4)
        self.stop_ambient_camera_rotation()
        
    def create_axes(self):
        """Create and return 3D axes"""
        axes = ThreeDAxes(
            x_range=[-4, 4, 1],
            y_range=[-4, 4, 1],
            z_range=[-4, 4, 1],
            x_length=8,
            y_length=8,
            z_length=8,
        )
        axes.scale(0.5)
        return axes
    
    def create_sphere(self):
        """Create sphere with labels"""
        sphere = Sphere(
            center=ORIGIN,
            radius=1.5,
            resolution=(24, 24),
            fill_color=BLUE,
            fill_opacity=0.3,
            stroke_color=BLUE,
            stroke_width=2,
        )
        
        # Mathematical notation for sphere
        center_label = MathTex(r"\vec{C}", color=BLUE).scale(0.8)
        radius_label = MathTex(r"r", color=BLUE).scale(0.8)
        center_label.next_to(sphere, UP + RIGHT)
        radius_label.next_to(center_label, RIGHT)
        
        return sphere, [center_label, radius_label]
    
    def show_algorithm_overview(self):
        """Display the algorithm steps"""
        algo_title = Text("Algorithm Steps:", font_size=32, color=YELLOW)
        algo_title.to_corner(UL)
        
        steps = VGroup(
            MathTex(r"1.\,\text{Ray:}\,\vec{P}(t) = \vec{O} + t\vec{D}", font_size=26),
            MathTex(r"2.\,\text{Sphere:}\,|\vec{P} - \vec{C}|^2 = r^2", font_size=26),
            MathTex(r"3.\,\text{Substitute ray into sphere}", font_size=26),
            MathTex(r"4.\,\text{Expand to quadratic:}\,at^2 + bt + c = 0", font_size=26),
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.25)
        steps.next_to(algo_title, DOWN, aligned_edge=LEFT)
        
        self.add_fixed_in_frame_mobjects(algo_title, steps)
        self.play(Write(algo_title))
        for step in steps:
            self.play(Write(step), run_time=0.8)
        self.wait(2)
        
        # Fade out and remove from fixed mobjects
        self.play(FadeOut(algo_title), FadeOut(steps))
        self.remove(algo_title, steps)
    
    def demonstrate_case(self, axes, sphere, origin, direction, name, color, symbol):
        """Demonstrate a single intersection case with symbolic math"""
        # Normalize direction
        direction = direction / np.linalg.norm(direction)
        
        # Create ray visualization
        ray_end = origin + 5 * direction
        ray = Arrow3D(
            start=origin,
            end=ray_end,
            color=YELLOW,
            thickness=0.02
        )
        
        # Origin and direction markers
        origin_dot = Sphere(center=origin, radius=0.06, color=YELLOW)
        
        # Case label
        case_label = Text(name, font_size=36, color=color)
        case_label.to_corner(UL)
        
        # Keep track of fixed mobjects for this case
        case_fixed_mobjects = []
        
        self.play(
            Create(ray),
            Create(origin_dot),
        )
        self.add_fixed_in_frame_mobjects(case_label)
        case_fixed_mobjects.append(case_label)
        self.play(Write(case_label))
        
        # Show symbolic calculation
        calc_mobjects = self.show_symbolic_calculation(symbol, color)
        case_fixed_mobjects.extend(calc_mobjects)
        
        # Calculate and show intersection points
        intersections = self.calculate_intersections(origin, direction, 1.5)
        point_labels = self.show_intersection_points(intersections, color)
        case_fixed_mobjects.extend(point_labels)
        
        self.wait(2)
        
        # Clean up everything for this case
        all_to_remove = [ray, origin_dot] + case_fixed_mobjects
        all_to_remove.extend([mob for mob in self.mobjects if isinstance(mob, Sphere) and mob.radius < 0.1])
        
        self.play(*[FadeOut(mob) for mob in all_to_remove])
        
        # Remove fixed mobjects from the scene
        for mob in case_fixed_mobjects:
            self.remove(mob)
    
    def show_symbolic_calculation(self, discriminant_symbol, color):
        """Display symbolic math for the current case"""
        # Quadratic coefficients
        coeffs = VGroup(
            MathTex(r"a = \vec{D} \cdot \vec{D} = |\vec{D}|^2", font_size=24),
            MathTex(r"b = 2\vec{D} \cdot (\vec{O} - \vec{C})", font_size=24),
            MathTex(r"c = |\vec{O} - \vec{C}|^2 - r^2", font_size=24),
        ).arrange(DOWN, aligned_edge=LEFT)
        coeffs.to_corner(UR)
        
        # Discriminant
        disc_eq = MathTex(
            r"\Delta = b^2 - 4ac",
            font_size=28
        )
        disc_result = MathTex(
            discriminant_symbol,
            font_size=32,
            color=color
        )
        
        disc_group = VGroup(disc_eq, disc_result).arrange(RIGHT, buff=0.5)
        disc_group.next_to(coeffs, DOWN, buff=0.5)
        
        self.add_fixed_in_frame_mobjects(coeffs, disc_group)
        self.play(Write(coeffs))
        self.play(Write(disc_eq), Write(disc_result))
        
        return [coeffs, disc_group]
    
    def calculate_intersections(self, origin, direction, radius):
        """Calculate intersection points algebraically"""
        oc = origin  # Since sphere is at origin
        a = np.dot(direction, direction)
        b = 2 * np.dot(direction, oc)
        c = np.dot(oc, oc) - radius**2
        
        discriminant = b**2 - 4*a*c
        intersections = []
        
        if discriminant >= 0:
            if discriminant == 0:
                t = -b / (2*a)
                if t >= 0:
                    intersections.append(origin + t * direction)
            else:
                sqrt_disc = np.sqrt(discriminant)
                t1 = (-b - sqrt_disc) / (2*a)
                t2 = (-b + sqrt_disc) / (2*a)
                
                for t in [t1, t2]:
                    if t >= 0:
                        intersections.append(origin + t * direction)
        
        return intersections
    
    def show_intersection_points(self, intersections, color):
        """Visualize intersection points"""
        points = []
        labels = []
        
        # Create all points first
        for i, point in enumerate(intersections):
            p = Sphere(
                center=point,
                radius=0.08,
                color=color,
                fill_opacity=1
            )
            points.append(p)
        
        # Animate points creation
        if points:
            self.play(*[Create(p) for p in points])
        
        # Then add labels after points exist
        for i, p in enumerate(points):
            label = MathTex(f"P_{i+1}", font_size=20, color=color)
            label.next_to(p, UP)
            self.add_fixed_in_frame_mobjects(label)
            labels.append(label)
            self.play(Write(label), run_time=0.3)
        
        return labels


class RaySphereIntersection2D(Scene):
    """2D visualization with detailed mathematical derivation"""
    
    def construct(self):
        # Title
        title = Text("Ray-Sphere Intersection: Mathematical Derivation", font_size=36)
        title.to_edge(UP)
        self.play(Write(title))
        self.wait(2)
        
        # Create coordinate system
        axes = Axes(
            x_range=[-5, 5, 1],
            y_range=[-3, 3, 1],
            x_length=10,
            y_length=6,
            axis_config={"color": GREY_B},
            tips=False,
        )
        axes.add_coordinates()
        
        # Fade out title and show axes
        self.play(FadeOut(title), Create(axes))
        
        # Create circle (2D sphere)
        circle = Circle(
            radius=1.5,
            color=BLUE,
            fill_opacity=0.2,
            stroke_width=3
        )
        center_dot = Dot(ORIGIN, color=BLUE)
        
        # Mathematical labels
        labels = VGroup(
            MathTex(r"\vec{C}", color=BLUE).next_to(center_dot, DOWN),
            MathTex(r"r", color=BLUE).move_to(axes.c2p(0.75, 0.75))
        )
        
        self.play(
            Create(circle),
            Create(center_dot),
            *[Write(label) for label in labels]
        )
        
        # Show derivation
        self.show_mathematical_derivation()
        
        # Animate the three cases
        self.animate_three_cases(axes, circle)
        
        self.wait(2)
    
    def show_mathematical_derivation(self):
        """Show step-by-step derivation"""
        derivation = VGroup(
            Text("Derivation:", font_size=28, color=YELLOW),
            MathTex(r"\text{Given:}", font_size=24),
            MathTex(r"\vec{P}(t) = \vec{O} + t\vec{D}", font_size=24),
            MathTex(r"|\vec{P} - \vec{C}|^2 = r^2", font_size=24),
            MathTex(r"\text{Substitute:}", font_size=24),
            MathTex(r"|\vec{O} + t\vec{D} - \vec{C}|^2 = r^2", font_size=24),
            MathTex(r"\text{Let } \vec{L} = \vec{O} - \vec{C}:", font_size=24),
            MathTex(r"|\vec{L} + t\vec{D}|^2 = r^2", font_size=24),
            MathTex(r"(\vec{L} + t\vec{D}) \cdot (\vec{L} + t\vec{D}) = r^2", font_size=24),
            MathTex(r"t^2(\vec{D} \cdot \vec{D}) + 2t(\vec{D} \cdot \vec{L}) + (\vec{L} \cdot \vec{L}) - r^2 = 0", font_size=24),
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.15)
        
        derivation.scale(0.8).to_corner(UL)
        
        for step in derivation:
            self.play(Write(step), run_time=0.6)
        
        # Highlight final quadratic form
        final_form = MathTex(
            r"at^2 + bt + c = 0",
            font_size=28,
            color=GREEN
        )
        final_form.next_to(derivation, DOWN, buff=0.3)
        
        self.play(Write(final_form))
        self.wait(2)
        self.play(FadeOut(derivation), FadeOut(final_form))
    
    def animate_three_cases(self, axes, circle):
        """Animate all three intersection cases"""
        cases = [
            {
                "start": axes.c2p(-4, -0.5),
                "direction": np.array([1, 0.2, 0]),
                "name": "Case 1: Two Intersections",
                "disc_sign": r"\Delta > 0",
                "solution": r"t = \frac{-b \pm \sqrt{\Delta}}{2a}",
                "color": GREEN
            },
            {
                "start": axes.c2p(-4, 1.5),
                "direction": np.array([1, 0, 0]),
                "name": "Case 2: Tangent",
                "disc_sign": r"\Delta = 0",
                "solution": r"t = \frac{-b}{2a}",
                "color": ORANGE
            },
            {
                "start": axes.c2p(-4, 2.2),
                "direction": np.array([1, 0, 0]),
                "name": "Case 3: Miss",
                "disc_sign": r"\Delta < 0",
                "solution": r"\text{No real solutions}",
                "color": RED
            }
        ]
        
        for case in cases:
            self.animate_single_case(axes, circle, **case)
    
    def animate_single_case(self, axes, circle, start, direction, name, disc_sign, solution, color):
        """Animate a single intersection case"""
        # Normalize direction
        direction = direction[:2] / np.linalg.norm(direction[:2])
        
        # Create ray
        end = start + 8 * direction
        ray = Arrow(start, end, color=YELLOW, buff=0, stroke_width=3)
        origin_dot = Dot(start, color=YELLOW)
        
        # Labels
        case_label = Text(name, font_size=30, color=color)
        case_label.to_corner(UR)
        
        # Mathematical conditions
        math_info = VGroup(
            MathTex(disc_sign, font_size=28, color=color),
            MathTex(solution, font_size=24)
        ).arrange(DOWN)
        math_info.next_to(case_label, DOWN)
        
        # Keep track of all objects created in this case
        case_objects = [ray, origin_dot, case_label, math_info]
        
        self.play(
            Create(ray),
            Create(origin_dot),
            Write(case_label),
            Write(math_info)
        )
        
        # Calculate and show intersections symbolically
        o = axes.p2c(start)
        d = direction
        
        # For visualization purposes, calculate actual intersections
        a = np.dot(d, d)
        b = 2 * np.dot(d, o)
        c = np.dot(o, o) - (1.5)**2
        
        discriminant = b**2 - 4*a*c
        
        intersection_objects = []
        
        if discriminant > 0:
            sqrt_disc = np.sqrt(discriminant)
            t1 = (-b - sqrt_disc) / (2*a)
            t2 = (-b + sqrt_disc) / (2*a)
            
            for i, t in enumerate([t1, t2]):
                if t > 0:
                    intersection = o + t * d
                    point = Dot(axes.c2p(intersection[0], intersection[1]), color=color, radius=0.08)
                    label = MathTex(f"t_{i+1}", font_size=20, color=color).next_to(point, UP)
                    intersection_objects.extend([point, label])
                    self.play(Create(point), Write(label), run_time=0.5)
        elif discriminant == 0:
            t = -b / (2*a)
            if t > 0:
                intersection = o + t * d
                point = Dot(axes.c2p(intersection[0], intersection[1]), color=color, radius=0.08)
                label = MathTex("t_0", font_size=20, color=color).next_to(point, UP)
                intersection_objects.extend([point, label])
                self.play(Create(point), Write(label), run_time=0.5)
        
        case_objects.extend(intersection_objects)
        
        self.wait(2)
        
        # Clean up all objects from this case
        self.play(*[FadeOut(obj) for obj in case_objects])

##manim -pql main.py RaySphereIntersection   # Preview, Low Quality (480p, 15fps)
##manim -pqm main.py SceneName   # Preview, Medium Quality (720p, 30fps)
#manim -pqh main.py SceneName   # Preview, High Quality (1080p, 60fps)
#manim -pqk main.py RaySphereIntersection   # Preview, 4K Quality (2160p, 60fps)

#RaySphereIntersection
#RaySphereIntersection2D

# Without preview (just render)
#manim -ql main.py SceneName    # Low Quality
#manim -qm main.py SceneName    # Medium Quality
#manim -qh main.py SceneName    # High Quality
#manim -qk main.py SceneName    # 4K Quality##
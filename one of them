from manim import *
import numpy as np

class RaySphereIntersection(Scene):
    def construct(self):
        # Title
        title = Text("Ray-Sphere Intersection", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(FadeOut(title))
        
        # Part 1: Show the three cases based on discriminant
        self.show_three_cases()
        
        # Part 2: Show quadratic formula application
        self.show_quadratic_solution()
        
        # Part 3: Show intersection point calculation
        self.show_intersection_calculation()
        
        # Part 4: Show which intersection is chosen
        self.show_intersection_choice()
    
    def show_three_cases(self):
        # Create three scenarios side by side
        cases_title = Text("Three Cases Based on Discriminant", font_size=36)
        cases_title.to_edge(UP)
        self.play(Write(cases_title))
        
        # Create three spheres
        sphere_configs = [
            {"center": LEFT * 4, "label": "Δ > 0\n(Two intersections)"},
            {"center": ORIGIN, "label": "Δ = 0\n(Tangent)"},
            {"center": RIGHT * 4, "label": "Δ < 0\n(No intersection)"}
        ]
        
        spheres = []
        rays = []
        labels = []
        dots_list = []
        
        for config in sphere_configs:
            # Create sphere
            sphere = Circle(radius=1.2, color=BLUE, fill_opacity=0.3)
            sphere.move_to(config["center"] + UP * 0.5)
            spheres.append(sphere)
            
            # Create label
            label = Text(config["label"], font_size=20)
            label.move_to(config["center"] + DOWN * 2)
            labels.append(label)
            
            # Create ray based on case
            if config["label"].startswith("Δ > 0"):
                # Ray passes through sphere
                start = config["center"] + LEFT * 3 + UP * 0.5
                end = config["center"] + RIGHT * 3 + UP * 0.5
                ray = Arrow(start, end, color=YELLOW, buff=0)
                rays.append(ray)
                
                # Add intersection points
                dot1 = Dot(config["center"] + LEFT * 1.2 + UP * 0.5, color=RED)
                dot2 = Dot(config["center"] + RIGHT * 1.2 + UP * 0.5, color=RED)
                dots_list.extend([dot1, dot2])
                
            elif config["label"].startswith("Δ = 0"):
                # Ray is tangent to sphere
                start = config["center"] + LEFT * 3 + UP * 1.7
                end = config["center"] + RIGHT * 3 + UP * 1.7
                ray = Arrow(start, end, color=YELLOW, buff=0)
                rays.append(ray)
                
                # Add tangent point
                dot = Dot(config["center"] + UP * 1.7, color=RED)
                dots_list.append(dot)
                
            else:  # Δ < 0
                # Ray misses sphere
                start = config["center"] + LEFT * 3 + UP * 2.5
                end = config["center"] + RIGHT * 3 + UP * 2.5
                ray = Arrow(start, end, color=YELLOW, buff=0)
                rays.append(ray)
        
        # Animate
        self.play(*[Create(s) for s in spheres])
        self.play(*[Create(r) for r in rays])
        self.play(*[Write(l) for l in labels])
        self.wait(1)
        self.play(*[Create(d) for d in dots_list])
        self.wait(2)
        
        # Clean up
        self.play(
            *[FadeOut(s) for s in spheres],
            *[FadeOut(r) for r in rays],
            *[FadeOut(l) for l in labels],
            *[FadeOut(d) for d in dots_list],
            FadeOut(cases_title)
        )
    
    def show_quadratic_solution(self):
        # Title
        title = Text("Applying the Quadratic Formula", font_size=36)
        title.to_edge(UP)
        self.play(Write(title))
        
        # Show the quadratic equation
        quad_eq = MathTex(
            r"At^2 + Bt + C = 0",
            font_size=40
        )
        quad_eq.move_to(UP * 2)
        
        # Show the quadratic formula
        quad_formula = MathTex(
            r"t = \frac{-B \pm \sqrt{B^2 - 4AC}}{2A}",
            font_size=40
        )
        quad_formula.move_to(ORIGIN)
        
        # Show the two solutions
        t1_eq = MathTex(
            r"t_1 = \frac{-B - \sqrt{\Delta}}{2A}",
            font_size=36
        )
        t1_eq.move_to(DOWN * 1.5 + LEFT * 2)
        
        t2_eq = MathTex(
            r"t_2 = \frac{-B + \sqrt{\Delta}}{2A}",
            font_size=36
        )
        t2_eq.move_to(DOWN * 1.5 + RIGHT * 2)
        
        discriminant = MathTex(
            r"\Delta = B^2 - 4AC",
            font_size=36
        )
        discriminant.move_to(DOWN * 2.8)
        
        # Animate
        self.play(Write(quad_eq))
        self.wait(1)
        self.play(Write(quad_formula))
        self.wait(1)
        self.play(Write(t1_eq), Write(t2_eq))
        self.wait(1)
        self.play(Write(discriminant))
        self.wait(2)
        
        # Clean up
        self.play(
            FadeOut(quad_eq),
            FadeOut(quad_formula),
            FadeOut(t1_eq),
            FadeOut(t2_eq),
            FadeOut(discriminant),
            FadeOut(title)
        )
    
    def show_intersection_calculation(self):
        # Title
        title = Text("Finding Intersection Points", font_size=36)
        title.to_edge(UP)
        self.play(Write(title))
        
        # Create sphere and ray
        sphere = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)
        sphere.move_to(ORIGIN)
        
        ray_start = LEFT * 4
        ray_end = RIGHT * 4
        ray = Arrow(ray_start, ray_end, color=YELLOW, buff=0)
        
        # Labels
        origin_label = MathTex("O", font_size=30)
        origin_label.next_to(ray_start, DOWN)
        
        direction_label = MathTex("D", font_size=30)
        direction_arrow = Arrow(ray_start, ray_start + RIGHT * 1.5, 
                               color=GREEN, buff=0, stroke_width=3)
        direction_label.next_to(direction_arrow, UP)
        
        # Show ray equation
        ray_eq = MathTex(
            r"P(t) = O + tD",
            font_size=36
        )
        ray_eq.to_edge(LEFT).shift(DOWN * 2)
        
        self.play(Create(sphere), Create(ray))
        self.play(Write(origin_label), Create(direction_arrow), Write(direction_label))
        self.play(Write(ray_eq))
        
        # Show intersection points
        t1_val = 0.35  # Normalized position along ray for first intersection
        t2_val = 0.65  # Normalized position along ray for second intersection
        
        p1 = ray_start + (ray_end - ray_start) * t1_val
        p2 = ray_start + (ray_end - ray_start) * t2_val
        
        dot1 = Dot(p1, color=RED, radius=0.1)
        dot2 = Dot(p2, color=RED, radius=0.1)
        
        p1_label = MathTex(r"P(t_1)", font_size=24, color=RED)
        p1_label.next_to(dot1, UP)
        
        p2_label = MathTex(r"P(t_2)", font_size=24, color=RED)
        p2_label.next_to(dot2, UP)
        
        # Show calculation
        calc1 = MathTex(
            r"P(t_1) = O + t_1 D",
            font_size=30
        )
        calc1.to_edge(RIGHT).shift(DOWN * 2)
        
        self.play(Create(dot1), Write(p1_label))
        self.play(Write(calc1))
        self.wait(1)
        
        self.play(Create(dot2), Write(p2_label))
        self.wait(2)
        
        # Clean up
        self.play(
            FadeOut(sphere), FadeOut(ray), FadeOut(origin_label),
            FadeOut(direction_arrow), FadeOut(direction_label),
            FadeOut(ray_eq), FadeOut(dot1), FadeOut(dot2),
            FadeOut(p1_label), FadeOut(p2_label), FadeOut(calc1),
            FadeOut(title)
        )
    
    def show_intersection_choice(self):
        # Title
        title = Text("Choosing the Correct Intersection", font_size=36)
        title.to_edge(UP)
        self.play(Write(title))
        
        # Create sphere and ray
        sphere = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)
        sphere.move_to(RIGHT * 1)
        
        ray_start = LEFT * 4
        ray_end = RIGHT * 4
        ray = Arrow(ray_start, ray_end, color=YELLOW, buff=0)
        
        # Camera/eye position
        eye = Dot(ray_start, color=GREEN, radius=0.15)
        eye_label = Text("Camera", font_size=24, color=GREEN)
        eye_label.next_to(eye, DOWN)
        
        self.play(Create(sphere), Create(ray), Create(eye), Write(eye_label))
        
        # Show both intersection points
        t1_val = 0.4  # First intersection (closer to camera)
        t2_val = 0.7  # Second intersection (farther from camera)
        
        p1 = ray_start + (ray_end - ray_start) * t1_val
        p2 = ray_start + (ray_end - ray_start) * t2_val
        
        dot1 = Dot(p1, color=RED, radius=0.12)
        dot2 = Dot(p2, color=GRAY, radius=0.12)
        
        # Labels with t values
        t1_label = MathTex(r"t_1 = 2.3", font_size=24, color=RED)
        t1_label.next_to(dot1, UP)
        
        t2_label = MathTex(r"t_2 = 4.7", font_size=24, color=GRAY)
        t2_label.next_to(dot2, DOWN)
        
        self.play(Create(dot1), Create(dot2))
        self.play(Write(t1_label), Write(t2_label))
        
        # Explanation
        explanation = Text(
            "We choose the smaller t value (t₁)\nbecause it's closer to the camera",
            font_size=24
        )
        explanation.to_edge(DOWN)
        
        # Highlight the chosen intersection
        highlight = Circle(radius=0.3, color=YELLOW, stroke_width=3)
        highlight.move_to(p1)
        
        self.play(Write(explanation))
        self.play(Create(highlight))
        self.play(highlight.animate.scale(1.2).set_stroke(width=5))
        self.play(highlight.animate.scale(1/1.2).set_stroke(width=3))
        
        # Show distance comparison
        dist_line1 = Line(ray_start, p1, color=RED, stroke_width=2)
        dist_line2 = Line(ray_start, p2, color=GRAY, stroke_width=1)
        
        self.play(Create(dist_line1))
        self.play(Create(dist_line2))
        
        final_note = Text(
            "The second intersection is hidden behind the first",
            font_size=20, color=GRAY
        )
        final_note.next_to(explanation, UP)
        
        self.play(Write(final_note))
        self.wait(3)
        
        # Final cleanup
        self.play(
            FadeOut(sphere), FadeOut(ray), FadeOut(eye), FadeOut(eye_label),
            FadeOut(dot1), FadeOut(dot2), FadeOut(t1_label), FadeOut(t2_label),
            FadeOut(explanation), FadeOut(highlight), FadeOut(dist_line1),
            FadeOut(dist_line2), FadeOut(final_note), FadeOut(title)
        )
        
        # End card
        end_text = Text("Ray-Sphere Intersection Complete", font_size=40)
        self.play(Write(end_text))
        self.wait(2)